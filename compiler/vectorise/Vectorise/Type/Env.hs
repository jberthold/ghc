{-# OPTIONS_GHC -XNoMonoLocalBinds #-}

-- Vectorise a modules type environment, the structure containing all type things defined in a
-- module.
--
-- This extends the type environment with vectorised variants of data types and produces value
-- bindings for worker functions and the like.

module Vectorise.Type.Env ( 
  vectTypeEnv,
) where
  
import Vectorise.Env
import Vectorise.Vect
import Vectorise.Monad
import Vectorise.Builtins
import Vectorise.Type.TyConDecl
import Vectorise.Type.Classify
import Vectorise.Type.PADict
import Vectorise.Type.PData
import Vectorise.Type.PRepr
import Vectorise.Type.Repr
import Vectorise.Utils

import CoreSyn
import CoreUtils
import CoreUnfold
import DataCon
import TyCon
import Type
import FamInstEnv
import Id
import MkId
import NameEnv
import NameSet

import Util
import Outputable
import FastString
import MonadUtils
import Control.Monad
import Data.List


-- Note [Pragmas to vectorise tycons]
-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
--
-- VECTORISE pragmas for type constructors cover three different flavours of vectorising data type
-- constructors:
--
-- (1) Data type constructor 'T' that may be used in vectorised code, where 'T' represents itself,
--     but the representation of 'T' is opaque in vectorised code.  
--
--     An example is the treatment of 'Int'.  'Int's can be used in vectorised code and remain
--     unchanged by vectorisation.  However, the representation of 'Int' by the 'I#' data
--     constructor wrapping an 'Int#' is not exposed in vectorised code.  Instead, computations
--     involving the representation need to be confined to scalar code.
--
--     'PData' and 'PRepr' instances need to be explicitly supplied for 'T' (they are not generated
--     by the vectoriser).
--
--     Type constructors declared with {-# VECTORISE SCALAR type T #-} are treated in this manner.
--     (The vectoriser never treats a type constructor automatically in this manner.)
--
-- (2) [NOT FULLY IMPLEMENTED YET]
--     Data type constructor 'T' that together with its constructors 'Cn' may be used in vectorised
--     code, where 'T' and the 'Cn' represent themselves in vectorised code.
--
--     An example is the treatment of 'Bool'.  'Bool' together with 'False' and 'True' may appear in
--     vectorised code and they remain unchanged by vectorisation.  (There is no need for a special
--     representation as the values cannot embed any arrays.)

--     'PData' and 'PRepr' instances are automatically generated by the vectoriser.
--
--     Type constructors declared with {-# VECTORISE type T #-} are treated in this manner.
--     (This is the same treatment that type constructors receive that the vectoriser deems fit for
--     use in vectorised code, but for which no special vectorised variant needs to be generated.)
--
-- (3) [NOT IMPLEMENTED YET]
--     Data type constructor 'T' that together with its constructors 'Cn' may be used in vectorised
--     code, where 'T' is represented by 'Tv' and the workers of the 'Cn' are represented 'vCn' in
--     vectorised code.
--
--     ??Example??
--
--     'PData' and 'PRepr' instances are automatically generated by the vectoriser.
--
--     ??How declared??

-- |Vectorise a type environment.
--
vectTypeEnv :: [TyCon]                  -- TyCons defined in this module
            -> [CoreVect]               -- All 'VECTORISE [SCALAR] type' declarations in this module
            -> VM ( [TyCon]             -- old TyCons ++ new TyCons
                  , [FamInst]           -- New type family instances.
                  , [(Var, CoreExpr)])  -- New top level bindings.
vectTypeEnv tycons vectTypeDecls
  = do { traceVt "** vectTypeEnv" $ ppr tycons

         -- Build a map containing all vectorised type constructor.  If they are scalar, they are
         -- mapped to 'False' (vectorised type constructor == original type constructor).
       ; allScalarTyConNames <- globalScalarTyCons  -- covers both current and imported modules
       ; vectTyCons          <- globalVectTyCons
       ; let vectTyConBase    = mapNameEnv (const True) vectTyCons   -- by default fully vectorised
             vectTyConFlavour = foldNameSet (\n env -> extendNameEnv env n False) vectTyConBase
                                            allScalarTyConNames

           -- Split the list of 'TyCons' into the ones (1) that we must vectorise and those (2)
           -- that we could, but don't need to vectorise.  Type constructors that are not data
           -- type constructors or use non-Haskell98 features are being dropped.  They may not
           -- appear in vectorised code.  (We also drop the local type constructors appearing in a
           -- VECTORISE SCALAR pragma, as they are being handled separately.)
       ; let localScalarTyCons      = [tycon | VectType tycon Nothing <- vectTypeDecls]
             localScalarTyConNames  = mkNameSet (map tyConName localScalarTyCons)
             notLocalScalarTyCon tc = not $ (tyConName tc) `elemNameSet` localScalarTyConNames

             maybeVectoriseTyCons   = filter notLocalScalarTyCon tycons
             (conv_tcs, keep_tcs)   = classifyTyCons vectTyConFlavour maybeVectoriseTyCons
             orig_tcs               = keep_tcs ++ conv_tcs
             keep_dcs               = concatMap tyConDataCons keep_tcs
             
             keep_and_scalar_tcs    = keep_tcs ++ localScalarTyCons

       ; traceVt " declared SCALAR: " $ ppr localScalarTyCons
       ; traceVt " reuse          : " $ ppr keep_tcs
       ; traceVt " convert        : " $ ppr conv_tcs

           -- Of those type constructors that we don't need to vectorise, we use the original
           -- representation in both unvectorised and vectorised code.  For those declared VECTORISE
           -- SCALAR, we ignore their represention â€” see "Note [Pragmas to vectorise tycons]".
       ; zipWithM_ defTyCon   keep_and_scalar_tcs keep_and_scalar_tcs
       ; zipWithM_ defDataCon keep_dcs keep_dcs

           -- Vectorise all the data type declarations that we can and must vectorise.
       ; new_tcs <- vectTyConDecls conv_tcs

           -- We don't need new representation types for dictionary constructors. The constructors
           -- are always fully applied, and we don't need to lift them to arrays as a dictionary
           -- of a particular type always has the same value.
       ; let vect_tcs = filter (not . isClassTyCon) 
                      $ keep_tcs ++ new_tcs

           -- Build 'PRepr' and 'PData' instance type constructors and family instances for all
           -- type constructors with vectorised representations.
       ; reprs     <- mapM tyConRepr vect_tcs
       ; repr_tcs  <- zipWith3M buildPReprTyCon orig_tcs vect_tcs reprs
       ; pdata_tcs <- zipWith3M buildPDataTyCon orig_tcs vect_tcs reprs
       ; let inst_tcs  = repr_tcs ++ pdata_tcs
             fam_insts = map mkLocalFamInst inst_tcs
       ; updGEnv $ extendFamEnv fam_insts

           -- Generate dfuns for the 'PA' instances of the vectorised type constructors and
           -- associate the type constructors with their dfuns in the global environment.  We get
           -- back the dfun bindings (which we will subsequently inject into the modules toplevel).
       ; (_, binds) <- fixV $ \ ~(dfuns, _) ->
           do { defTyConPAs (zipLazy vect_tcs dfuns)
              ; dfuns <- sequence 
                      $  zipWith4 buildTyConBindings
                                  orig_tcs
                                  vect_tcs
                                  repr_tcs
                                  pdata_tcs

              ; binds <- takeHoisted
              ; return (dfuns, binds)
              }

           -- We return: (1) the vectorised type constructors, (2)
           -- their 'PRepr' & 'PData' instance constructors two.
       ; let new_tycons = tycons ++ new_tcs ++ inst_tcs

       ; return (new_tycons, fam_insts, binds)
       }


-- Helpers -------------------

buildTyConBindings :: TyCon -> TyCon -> TyCon -> TyCon -> VM Var
buildTyConBindings orig_tc vect_tc prepr_tc pdata_tc
 = do { vectDataConWorkers orig_tc vect_tc pdata_tc
      ; repr <- tyConRepr vect_tc
      ; buildPADict vect_tc prepr_tc pdata_tc repr
      }

vectDataConWorkers :: TyCon -> TyCon -> TyCon -> VM ()
vectDataConWorkers orig_tc vect_tc arr_tc
 = do bs <- sequence
          . zipWith3 def_worker  (tyConDataCons orig_tc) rep_tys
          $ zipWith4 mk_data_con (tyConDataCons vect_tc)
                                 rep_tys
                                 (inits rep_tys)
                                 (tail $ tails rep_tys)
      mapM_ (uncurry hoistBinding) bs
 where
    tyvars   = tyConTyVars vect_tc
    var_tys  = mkTyVarTys tyvars
    ty_args  = map Type var_tys
    res_ty   = mkTyConApp vect_tc var_tys

    cons     = tyConDataCons vect_tc
    arity    = length cons
    [arr_dc] = tyConDataCons arr_tc

    rep_tys  = map dataConRepArgTys $ tyConDataCons vect_tc


    mk_data_con con tys pre post
      = liftM2 (,) (vect_data_con con)
                   (lift_data_con tys pre post (mkDataConTag con))

    sel_replicate len tag
      | arity > 1 = do
                      rep <- builtin (selReplicate arity)
                      return [rep `mkApps` [len, tag]]

      | otherwise = return []

    vect_data_con con = return $ mkConApp con ty_args
    lift_data_con tys pre_tys post_tys tag
      = do
          len  <- builtin liftingContext
          args <- mapM (newLocalVar (fsLit "xs"))
                  =<< mapM mkPDataType tys

          sel  <- sel_replicate (Var len) tag

          pre   <- mapM emptyPD (concat pre_tys)
          post  <- mapM emptyPD (concat post_tys)

          return . mkLams (len : args)
                 . wrapFamInstBody arr_tc var_tys
                 . mkConApp arr_dc
                 $ ty_args ++ sel ++ pre ++ map Var args ++ post

    def_worker data_con arg_tys mk_body
      = do
          arity <- polyArity tyvars
          body <- closedV
                . inBind orig_worker
                . polyAbstract tyvars $ \args ->
                  liftM (mkLams (tyvars ++ args) . vectorised)
                $ buildClosures tyvars [] arg_tys res_ty mk_body

          raw_worker <- mkVectId orig_worker (exprType body)
          let vect_worker = raw_worker `setIdUnfolding`
                              mkInlineUnfolding (Just arity) body
          defGlobalVar orig_worker vect_worker
          return (vect_worker, body)
      where
        orig_worker = dataConWorkId data_con
